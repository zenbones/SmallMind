= Smallmind
:doctype: book
:toc: auto
:icons: font
A journey through glue code

[preface]
The SmallMind project is about all the pieces of functionality you need to take care of after you've written your business logic. It's about logging, pooling, monitoring, caching and remoting. It's about doing all this without assumptions or privilege, so that every piece can be dropped, adapted, or extended. This project is opinionated, but we hope those opinions come out of a thoughtful and positive place.

== About

This is a work in progress, which is to say it's mostly code. We're open to opinions, modifications, questions, and, above all, help, because if there's any point to this project, it's to be helpful.

=== Download

All Smallmind modules are pushed to Maven Central under the *org.smallmind* group id. All artifacts which are intended to work together have the same sem version. Explicit module listings can be found in the various sections of this document covering those modules. Wherever possible, dependencies of this project are marked as `<optional>true</optional>`. This does require projects using these libraries to include such dependencies along with the relevant Smallmind modules, but keeps this project from making unwanted decisions. If we've missed any such opportunities, please let us know.

=== Configuration

There is none. IOC projects provide both the base container and configuration. Smallmind provides some occasionally helpful Spring beans, but there's no magic in them. Whatever flavor of dependency injection you prefer should work just as well.

=== Modules

* <<claxon>> - A unified monitoring framework with extensible meters and pluggable metric warehousing integrations (comes with Datadog, JMX, Logging and Prometheus).
* <<doppelganger>> - An annotation-based data transfer object generating facility that can create multiple polymorphic-aware, fully-validated, JAXB and REST compliant views, from a single description.
* <<scribe>> - A fast, light, easily extended, endpoint neutral, library safe, unified logging framework with decidedly lazy message interpolation.
* <<spark>> - Maven packaging formats for the construction of self-contained executable build artifacts.

[[claxon, Claxon]]
= Claxon

[partintro]
Claxon is a unified code instrumentation and metric gathering framework that abstracts away the underlying metric warehousing systems, allowing new systems to be plugged in and replaced as needed. It can be safely used as a dependency in libraries to provide instrumentation in a warehouse agnostic fashion, without forcing any particular notion of the underlying metrics storage system on the library adopter. New meters can be created without reference to the eventual warehousing system, and new warehouses can be integrated and used with all Claxon meters.

== Install

To use Claxon you need the `claxon-registry` dependency, and you may add dependencies for any emitters you're interested in the various `claxon-emitter-*` modules. There's also a simple Http endpoint for scraping pull-based emitters in the `claxon-http` module.

.Claxon Registry
[source,xml]
----
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>claxon-registry</artifactId>
  <version>LATEST</version>
</dependency>
----

.Claxon Push-based Integrations
[source,xml]
----
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>claxon-emitter-datadog</artifactId>
  <version>LATEST</version>
</dependency>
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>claxon-emitter-jmx</artifactId>
  <version>LATEST</version>
</dependency>
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>claxon-emitter-logging</artifactId>
  <version>LATEST</version>
</dependency>
----

[[claxon-maven-pull-based, Pull-based Integrations]]
.Claxon Pull-based Integrations
[source,xml]
----
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>claxon-emitter-prometheus</artifactId>
  <version>LATEST</version>
</dependency>
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>claxon-http</artifactId>
  <version>LATEST</version>
</dependency>
----

== Acknowledgments

Thanks to Dropwizard Metrics, micrometer.io and HdrHistogram.

== Design Choices

Metric warehousing systems such as StatsD, InfluxDB or Prometheus all store and provide for the querying of time series data. Some systems allow for the calculation of aggregations (minimums, maximums, velocity, histograms, etc.) upon storing data points, or as part of the provided query capabilities, while others do not. Some systems we may want to integrate with, such as JMX, have no notion of a time series at all. A project such as this one might fulfill its goals by fixing its notion of the meters it allows, and then pushing the responsibility of implementing each of those meters onto the warehouse integrations. This would allow integrations with systems with a built-in notion of aggregations to take advantage of those capabilities. We have instead chosen to ignore most of the differences between warehousing systems, and separate the implementation of meters from the underlying capabilities of the various data stores. That doesn't mean that you can't choose to build your own meters and warehousing integrations that are more tightly coupled, it just means that the meters provided by this project all aggregate on the client, and are uniformly usable on both the provided warehouse integrations, or with new integrations you may choose to create. It means that this framework does not privilege its provided meters in any way, and all of its capabilities, including AOP instrumentation annotations, are extended to any meters you choose to create. Further, you can create new warehouse integrations without having to provide implementations for any meters at all, and those integrations will be usable with all meters which fulfill the contracts for this project.

== Registry

The ClaxonRegistry holds both meters (`org.smallmind.claxon.registry.meter.Meter`) and warehouse integration bindings (`org.smallmind.claxon.registry.Emitter`). Meters should be obtained through the ClaxonRegistry, which accepts the MeterBuilder interface (org.smallmind.claxon.registry.meter.MeterBuilder) through its `register()` method, as opposed to meter implementations directly. MeterBuilder is intended to take only the necessary parameters for constructing instances of Meter, and to be itself lightweight, so that the cost of not building a meter (if already present in the registry) is negligible. If the construction of a meter can't be directly trivialized, this project provides a lazy indirection (`org.smallmind.claxon.registry.meter.LazyBuilder`) which can delay the use of a MeterBuilder until the point of necessity. On the back side, implementations of Emitter are bound by name through the registry's `bind()` method, and called with all aggregated metrics on the configured collection interval. Let's take a closer look at the useful bits...

=== Bind

[small]#`ClaxonRegistry bind(String name, Emitter emitter)`#

Installs and binds an emitter to the specified name, which will then start receiving updates. Reusing a name will rebind that name to the new emitter.

[[claxon-registry-register, Register]]
=== Register

[small]#`<M extends Meter> M register(Class<?> caller, MeterBuilder<M> builder, Tag... tags)`#

Creates and registers a meter if it's not already registered, otherwise returns the currently registered meter. A meter's uniqueness is a combination of the caller's class and the tags passed as parameters to this method. Although the calling class is intended to be the direct caller of this method, that's not a requirement. Think of it the same way many logging systems use a class as the log name, which is intended, but not required to be the class doing the logging. In a similar fashion, whether this meter actually outputs any metrics, and the namespace of those metrics (as passed to this registries bound emitters), will depend upon the class of the caller (see <<claxon-configuration>>). Every possible Meter should have a MeterBuilder available. We recommend that a meter of type Foo have a builder in the same package named FooBuilder, and this is the practice followed in this project. This MeterBuilder makes up the second parameter to this method, followed by any tags, where a Tag is a simple key/value pair of strings.

==== Example

registry.register(MyInstance.class, new GaugeBuilder(), new Tag("event", "update"), new Tag("source", "mysql"))

[NOTE]
Many metric warehouses are capable of storing and querying multi-dimensional data, and it's the tags used in creating a metric which will become the dimensions of the time series formed by the metric's values. Where a warehouse system is not multi-dimensional, the tags will be used to determine the time series data's hierarchical namespace. In either case, it's best to use tags with consistent ordering and limited cardinality (see <<claxon-tags>> for further advice).

=== Unregister

[small]#`void unregister(Class<?> caller, Tag... tags)`#

You should probably avoid unregistering and re-registering a meter, but if you know that a meter will no longer be used, and should be available for garbage collection, you can call this method.

=== Track _Observable_

[small]#`<O extends Observable> O track(Class<?> caller, MeterBuilder<?> builder, O observable, Tag... tags)`#

Registers a meter that will track changes in an Observable. The Observable instance is only weakly referenced by the meter, so that if the meter is the only remaining reference to the Observable instance, the meter will be unregistered and both the Observable instance and the meter will be available for garbage collection.

=== Track _Lambda_

[small]#`<T> T track(Class<?> caller, MeterBuilder<?> builder, T measured, Function<T, Long> measurement, Tag... tags)`#

Registers a meter that will poll the state of a 'measured' instance on the registry's collection interval using the supplied measurement function. Much like the tracking of Observables above, the measured instance is weakly held, such that if the meter is the only remaining reference, the meter will be unregistered and both the measured instance and the meter will be available for garbage collection.

[[claxon-configuration, Configuration]]
=== Configuration

The configuration for Claxon is simple and, like all SmallMind modules, programmatic. A configuration instance is composed of the following types...

* *Clock* (_clock_) - A clock can provide both wall time (think milliseconds since the epoch) and monotonic time (think nanoseconds). The default clock should work perfectly well, so you should not normally need to set your own.
* *Stint* (_collectionStint_) - The collection interval. The default value represents a 2-second interval.
* *Tag[]* (_registryTags_) - A set of default tags which are to be added to every meter. The default value is empty.
* *NamingStrategy* (_namingStrategy_) - The logic by which the `Class<?> caller` of meter registrations (see <<claxon-registry-register>> above) are turned into the root names of the quantities emitted by those meters (see <<claxon-meters>> below). The default value is the <<claxon-configuration-implied-naming-strategy>>.

[[claxon-naming-strategy, NamingStrategy]]
==== NamingStrategy

The purpose of meters is to emit metrics, or _quantities_ in the parlance of this project (see <<claxon-meters-quantities>> below). Every registered meter has a root name, and every quantity emitted by a meter has a name. The concatenation of the meter's root name with each quantity's name will form the _full_ name of that quantity passed to each of the registry's bound <<claxon-emitters>>. For most types of metric warehouses, the full name of each quantity will form the namespace of the time series created by that quantity's values. Because the emitted quantity namespaces will generally have limited cardinality (for the root names of meters and certainly for the quantity names), it's the Tags submitted with the registration which must guarantee the uniqueness of those namespaces. The root name of a meter is determined by the `Class<?> caller` parameter passed to the `register()` method (see <<claxon-registry-register>> above) via the NamingStrategy (`org.smallmind.claxon.registry.NamingStrategy`) in the registry's configuration. There are two naming strategies included in this project, the *ObviousNamingStrategy* and the *ImpliedNamingStrategy*.

===== ObviousNamingStrategy

[small]#`org.smallmind.claxon.registry.ObviousNamingStrategy``#

The ObviousNamingStrategy holds a Set of <<claxon-dot-notation>> instances which it attempts to match against the names of the caller classes submitted with meter registrations. If any match can be found, then the *full name of the caller class* becomes the root name of the registered meter. If no match can be found, then no meter will be registered, and no metrics will be emitted.

[TIP]
The diversity of this naming should ease the pressure on submitted Tag sets to guarantee the unique namespaces of warehoused time series, however, creators of libraries using this project should not count on this, as it's the choice of the library consumer. It's best to generate Tag sets with enough total cardinality to guarantee unique time series namespaces in their own right.

[[claxon-configuration-implied-naming-strategy, ImpliedNamingStrategy]]
===== ImpliedNamingStrategy

[small]#`org.smallmind.claxon.registry.ImpliedNamingStrategy`#

The ImpliedNamingStrategy holds a Map of _<<claxon-dot-notation>> to String_ entries. This strategy attempts to match the dot notated keys against the names of the caller classes submitted with meter registrations. If no match can be found, then no meter will be registered, and no metrics will be emitted. If one or more matches are found, then the strongest match, which is the one matching the most dot notated segments in the name, will determine the root name for that meter, which will be the String *value* of the winning map entry. Although there's no constraint on the values of this strategy's mappings, it's recommended to use dot notated names. This is the default naming strategy for Claxon configurations.

[TIP]
If you wanted to emit all metrics with a single root name you could add a single _prefixMap_ entry like `put(new DotNotation("*"), "my.metrics")`. Multiple entries can map to the same value, but even if each entry maps to a unique root name, the resulting namespaces are likely to be crowded. It is, therefore, very important that the Tag set registered for each meter guarantee the appropriate differentiation.

[[claxon-dot-notation, DotNotation]]
===== DotNotation

[small]#`org.smallmind.nutsnbolts.util.DotNotation`#

A DotNotation instance represents a pattern match of '.' separated segments, with 2 possible wildcards.

* *?* - Represents any single segment.
* *** - Represents any number of segments.

The greater the number of segments in the matching pattern, the stronger the match is considered, with an exact match counting slightly more than a wildcard match, which will roughly translate to the longest match, by segments, with the fewest wild cards.

===== Examples

The pattern "com.my.names' would match only the exact string, "com.my.names", while the pattern "com.my.?.names.*" would match any dot notated string starting with "com.my." followed by any single segment (a series of characters which was not a '.'), followed by at least one (or any greater number) of dot notated segments.

=== Instrumentation

To make use of this project, you could pass around a registry instance and directly call the `register()` method on it as needed, but that would be less than convenient. Instead, it's easier to interact with the registry through the static methods of the Instrument (`org.smallmind.claxon.registry.Instrument`) class. Instrument uses a thread local context to gain access to the underlying registry, while presenting both a direct access interface that mimics the `register()` and `track()` methods, as well as constructs for wrapping blocks of code with timing-based metrics. Turning on this functionality involves two bits of setup.

. Create an instance of PerApplicationContext (`org.smallmind.nutsnbolts.lang.PerApplicationContext`) which will not be subject to garbage collection for the life of the registry. The easiest way to do this is to create it as a _bean_ within the same IOC (inversion of control) context that you use to configure the Claxon registry instance.
+
[TIP]
====
As old fashioned as this may seem, in Spring xml this would be as simple as...

[source,xml]
----
<bean id="perApplicationContext" class="org.smallmind.nutsnbolts.lang.PerApplicationContext"/>
----
====

. Call the `initializeInstrumentation()` method of the configured ClaxonRegistry instance.
+
[TIP]
The provided `org.smallmind.claxon.registry.spring.ClaxonRegistryFactoryBean` does this for you, if you're using Spring.

==== With

[small]#`Instrumentation with (Class<?> caller, MeterBuilder<?> builder, Tag... tags)`#

The prerequisites taken care of, Instrument functionality is accessed through its `with()` method. This method takes the same _caller_, _builder_ and _tags_ parameters as the `register()` method discussed previously (see <<claxon-registry-register>> above), but returns an instance of the Instrumentation (`org.smallmind.claxon.registry.Instrumentation`) interface. Through this interface you can...

* `track()` to follow either an Obervable object, or any object coupled with a measuring function, as you can with the ClaxonRegistry directly.
+
[NOTE]
====
[source,java]
----
LinkedList<?> myList = new LinkedList();
Instrument.with(MyClass.class, new GaugeBuilder(), new Tag("pool", "used")).track(myList, list -> (long)list.size());
----
====

* `update()` the registered meter with a value, either a simple long value in the default time units (milliseconds), or with an explicit TimeUnit.
+
[NOTE]
====
[source,java]
----
Instrument.with(MyClass.class, new GaugeBuilder(), new Tag("event", "myevent")).update(12345);
----
====

* call `as()` to set the default time unit of the Instrumentation instance.
* call `on()` to wrap a block of code in timing metrics (passed as a Lambda with or without a return value).
+
[NOTE]
====
[source,java]
----
Instrument.with(MyClass.class, new SpeedometerBuilder(), new Tag("event", "myevent"),new Tag("service", "myservice")).on(() -> {
  ...
  instrumented code
  ...
});
----
====

==== Annotations

Although Instrument/Instrumentation together present a fairly simple and fluent interface, Claxon also allows wrapping methods in timing-based metrics via the use of annotations. You can do this not only with the meters which come built in, but also any you might develop.

===== @Instrumented

[small]#`org.smallmind.claxon.registry.aop.Instrumented`#

The root annotation is @Instrumented, which can be applied to both methods and constructors, and takes the following values...

* `Class<?> caller () default Instrumented.class` - The caller which will be passed to the meter registration.
* `ConstantTag[] constants () default {}` - An array of <<claxon-instrumentation-constant-tag>> which defines those tags with constant values that will be passed to the meter registration.
* `ParameterTag[] parameters () default {}` - An array of <<claxon-instrumentation-parameter-tag>> which defines those tags whose values will be pulled from the parameters of the annotated method, and then passed to the meter registration.
* `TimeUnit timeUnit () default TimeUnit.MILLISECONDS` - The time units for the `update()` to the registered meter.
* `boolean active () default true` - Whether this meter is active. If this value is false, no timing update will occur.
* `Class<? extends InstrumentedParser<?>> parser ()` - The class of the <<claxon-instrumentation-instrumented-parser>> which will be used to decode the json string from this annotation (see the json value next), in order to produce a MeterBuilder that will be passed to the meter registration.
* `String json () default "{}"` - The json formatted string representing the meter to be registered via this annotation.

[[claxon-instrumentation-constant-tag, @ConstantTag]]
====== @ConstantTag

Represents a tag whose keys and values are simple string constants.

[[claxon-instrumentation-parameter-tag, @ParameterTag]]
====== @ParameterTag

Represents a tag whose keys are string constants, but whose values are the names of parameters of the annotated method, and whose values will be pulled from those parameters (via their `toString()` methods).

[[claxon-instrumentation-instrumented-parser, InstrumentedParser]]
====== InstrumentedParser

[small]#`org.smallmind.claxon.registry.aop.InstrumentedParser`#

A json parser that accepts a json formatted string and returns an instance of MeterBuilder. Because the parsing of json is a more heavy-weight process that may be repeated many, many times, implementations of this interface will not actually be called unless a new Meter instance is to be constructed, which will only happen if the registry does not already contain an instance matching the caller class and tags. To allow meters you design to be used in @Instrumented annotations, all you need do is create an implementation of this interface and publish its json format and requirements.

====== Example

The following would register a Histogram (`org.smallmind.claxon.registry.meter.Histogram`) and update that meter with the time `myMethod()` takes to execute (in the default time unit of milliseconds). The tags would have the set "const1", "param1" and "param2", where `param1` and `param2` would take their values from the method parameters (_parameter1_ and _parameter2_). The histogram would be built with 2 significant digits of storage, lowest discernible value of 1, highest of 3600000 and tracking percentiles at 75%, 95% and 99%...

[source,java]
----
@Instrumented(
  caller = MyClass.class,
  constants = @ConstantTag(key = "const1", constant = "value"),
  parameters = {@ParameterTag(key = "param1", parameter = "parameter1"), @ParameterTag(key = "param2", parameter = "parameter2")},
  parser = HistogramParser.class,
  json = "{\"numberOfSignificantValueDigits\": 2, \"lowestDiscernibleValue\": 1, \"highestTrackableValue\": 3600000, \"percentiles\": [{\"name\": \"p75\", \"value\": 75.0}, {\"name\": \"p95\", \"value\": 95.0}, {\"name\": \"p99\", \"value\": 99.0}]}"
)
public SomeClass myMethod (String parameter1, int parameter2) {
  ...
  instrumented code
  ...
}
----

[[claxon-meters, Meters]]
== Meters

[small]#`org.smallmind.claxon.registry.meter.Meter`#

A meter in Claxon is an interface with two methods to implement, `update()` and `record()`.

* `void update (long value)` - This method takes a long value and updates the meter. What that means is entirely dependent on the meter, but, generally, the meter will be tracking some series of aggregations over time, to which the updated value will be appended.
* `Quantity[] record ()` - When this method is called by the registry, on the collection interval, the meter should return an array of Quantity instances holding the names and values of its aggregations (or whatever other quantities the meter is designed to track).

Pretty simple. The only complexity is that meters should be multi-thread safe and, as far as possible, lock free and wait free. Multiple threads may be calling the `update()` method at any one time, and, while only one thread *should* be calling `record()`, we don't want updates waiting on each other any more than necessary. Nor should record calls block update operations, and update calls should definitely *not* block record operations. On top of this, a meter must be ready to aggregate its updates in between collection cycles so as not to lose data. And because there's no guarantee of the exact timing of collection cycles, reporting of aggregates that are stated per time unit should internally track the time passed since the last collection, in order to be as accurate as possible.

[TIP]
The Meter implementations in this project use a series of helper classes in the `org.smallmind.claxon.registry.aggregate` package. You may find these helpers useful when designing your own meters as well. You may also want to look at the meter implementations themselves in `org.smallmind.claxon.registry.meter`. Not that the code is any good, but we can always use the help making it better.

[[claxon-meters-quantities, Quantities]]
=== Quantities

[small]#`org.smallmind.claxon.registry.Quantity`#

A quantity is a just container for a String name and a double value. The name of each quantity will be concatenated with the root name provided by the emitting meter to create a namespace for the value that's passed to each warehouse emitter. Exactly how this name is expressed, along with the meter's tags, is up to the logic within each emitter (see <<claxon-emitters>> below). We recommend that quantity names by kept simple. You can distinguish multi-word names via dot notation, hyphens, camel case, or simply smooshing them all together, but be prepared for the emitters to less sophisticated systems to mess with your naming, so simpler is better. We recommend sticking to dot notated names in most cases.

=== Out Of The Box

This project includes a set of Meters in the `org.smallmind.claxon.registry.meter` package.

* *Gauge* - Emits the "minimum", "maximum" and "average" of the updated values over the collection cycle.
* *Histogram* - Emits the "count" of updates, their "velocity", the "minimum", "maximum", "mean", and a set of specified quantiles over the collection cycle.
* *Speedometer* - Emits the "minimum", "maximum" and "velocity" of the updated values over the collection cycle.
* *Tachometer* - Emits just the "velocity" of the updated values over the collection cycle.
* *Tally* - Emits the running total of all updated values (which can be both positive and negative) over the life of the meter.
* *Trace* - Emits the exponential decaying average of the updated values over a set of specified time windows.

[[claxon-tags, Tags]]
== Tags

[small]#`org.smallmind.claxon.registry.Tag`#

A tag is a String name and value. Emitters for warehouses capable of multi-dimensional indexing can usually pass tags directly through to the underlying system. Emitters that represent warehouses that hold time series data, but are not multi-dimensional, will have to use the tags as part of the hierarchical namespace created for each emitted quantity. Other systems will do what they can to create the best experience possible. You can help this process by trying to stick to a few rules...

* Tag names should be kept simple, and, where multi-word names must be used, dot notating is probably best.
* Tag values should have low cardinality where possible. It makes the eventual use of the underlying systems easier. Obviously, a cardinality of 1 is probably too low, and should be either omitted or included in the quantity namespace.
* The Tag set should represent a robust uniqueness, by which we mean that it's unlikely to be duplicated, as a totality, by some other library that happens to be included in the same project. In the end, the client should be able to sort out the proper namespaces given package naming conventions and the available <<claxon-naming-strategy>> implementations. However, each library doing its part will make the whole that much easier to work with.

[[claxon-emitters, Emitters]]
== Emitters

[small]#`org.smallmind.claxon.registry.Emitter`#

There are essentially 2 different ways that metric warehouses ingest data, via either push (such as over a socket, REST API, or by method call) or pull (such as an HTTP scrape endpoint). Although you could implement the Emitter interface directly, we advise extending either the <<claxon-emitters-push-emiiter>> or <<claxon-emitters-pull-emiiter>> abstract classes. In either case, the only requirement is implementing the `record()` method.

* `void record (String meterName, Tag[] tags, Quantity[] quantities)` - The record method is called on each collection cycle once for each registered meter. It's passed the root name of the meter (as determined by the <<claxon-naming-strategy>> in force), an array of the tags registered for that meter, and an array of the quantities being emitted. Whatever an emitter chooses to do with this information should be done efficiently and without blocking. It's up to an emitter to handle any long running operations in an asynchronous fashion, sensitive to the fact that record might be called again before the current asynchronous operation is complete.

[[claxon-emitters-push-emiiter, PushEmitter]]
=== PushEmitter

A PushEmitter can generally take the information in the record call and translate it to the underlying warehouse system, assuming such calls are efficient in their own right.

[small]#`org.smallmind.claxon.registry.PushEmitter`#

[[claxon-emitters-pull-emiiter, PullEmitter]]
=== PullEmitter

[small]#`org.smallmind.claxon.registry.PullEmitter`#

A PullEmitter will have to store and forward incoming time series data by necessity. Given that Claxon expects meters to aggregate updates between collection intervals, pull-based emitters may be receiving multiple sets of aggregates before being able to pass that data on to the underlying warehouse, depending on the timing of Claxon collection cycles and those of the underlying system. As the methods of aggregation, if any, will vary from meter to meter, a pull-based emitter can't simply squash aggregates together, and should be prepared to send them on as independent values, along with their original timestamps.

==== EmitterResource

[small]#`org.smallmind.claxon.http.EmitterResource`#

Claxon provides a generic Jersey REST API endpoint for pull-based emitters, such as Prometheus, available in the *claxon-http* artifact (see <<claxon-maven-pull-based>> above). If the provided implementation is not appropriate for your project, building your own should be simple enough considering the few lines of code it took to implement ours.

=== Out Of The Box

Claxon provides emitters for the following systems as part of this project...

==== DataDog

This is fairly straightforward. The integration uses DataDog's StatsD capabilities, which, being UDP-based, is very fast, and cares little about the choice of characters in its namespace or tags. It's push capable, allowing aggregations to be forwarded as necessary. DataDog prefers dot notated names, in keeping with the general precedent set by almost every programming language, which lowers the impedance mismatch which might otherwise occur. All quantities are output as gauge values, as all aggregation is assumed to be handled client side. All of this should lead to an experience with few surprises.

==== JMX

JMX knows nothing about time series, so the resulting management beans will contain only the last known data points. The translation is otherwise pretty direct, with dot notated meter names making up the JMX domain name, tags creating the attendant properties, and quantity names translating to available fields.

==== Message

A very simple translation to string values handed off to a `Consumer<String>`, intended for easy integration with logging systems.

==== Prometheus

Beware when using Prometheus that its scrape protocol is limited. You might think it would be easy enough to allow multiple data points for any single time series, within the same scrape Http body, by referencing the timestamp value the protocol allows to be included with each data point, and, where that was either not present or not sufficient, relying on the simple ordering of the values themselves. However, that is not the case and multiple data points for the same series will be lost. Due to this limitation, Claxon's Prometheus integration will only report the last data point received for any series since the last scrape request. It's important, therefore, to have your Prometheus instance scrape the Claxon endpoint at least as often as Claxon is set to report its aggregated values. In practical terms...

[WARNING]
The Prometheus collection interval must be less than or equal to the Claxon collection interval as defined by `ClaxonConfiguration.getCollectionStint()`, _or you may lose data points_.

===== Naming

Prometheus does not allow dot notated names, nor anything but the most basic ascii characters and numbers. The more natural dot notated names used by Claxon will be translated to underscore separated names. Most everything otherwise inadmissible for prometheus will also end up as underscores. Fortunately, prometheus is muti-dimensional and Claxon's guidelines for tags are in line with those promulgated by Prometheus.

== Configuration

The following is one possible configuration that's demonstrative of a simple but realistic scenario. It's in Spring XML format, but should be indicative of what's necessary in any injection framework...

.Spring XML
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="claxonEmitter" class="org.smallmind.claxon.emitter.prometheus.PrometheusEmitter"/>

  <bean id="claxonEmitterResource" class="org.smallmind.claxon.http.EmitterResource">
    <property name="registry" ref="claxonRegistry"/>
  </bean>

  <bean id="claxonRegistry" class="org.smallmind.claxon.registry.spring.ClaxonRegistryFactoryBean">
    <property name="configuration">
      <bean class="org.smallmind.claxon.registry.ClaxonConfiguration">
        <property name="collectionStint">
          <bean class="org.smallmind.claxon.registry.spring.StintFactoryBean">
            <property name="time" value="3"/>
            <property name="timeUnit" value="SECONDS"/>
          </bean>
        </property>
        <property name="namingStrategy">
          <bean class="org.smallmind.claxon.registry.ImpliedNamingStrategy">
            <property name="prefixMap">
              <map>
                <entry value="com.mycompany.metric.http">
                  <key>
                    <bean class="org.smallmind.nutsnbolts.util.DotNotation">
                      <property name="notation" value="com.mycompany.instrument.rest.*"/>
                    </bean>
                  </key>
                </entry>
                <entry value="com.mycompany.metric.persistence">
                  <key>
                    <bean class="org.smallmind.nutsnbolts.util.DotNotation">
                      <property name="notation" value="org.smallmind.persistence.cache.*"/>
                    </bean>
                  </key>
                </entry>
                 <entry value="com.mycompany.metric.persistence">
                  <key>
                    <bean class="org.smallmind.nutsnbolts.util.DotNotation">
                      <property name="notation" value="org.smallmind.persistence.orm.*"/>
                    </bean>
                  </key>
                </entry>
                <entry value="com.mycompany.metric.task">
                  <key>
                    <bean class="org.smallmind.nutsnbolts.util.DotNotation">
                      <property name="notation" value="com.mycompany.task.*"/>
                    </bean>
                  </key>
                </entry>
                <entry value="com.mycompany.metric.unknown">
                  <key>
                    <bean class="org.smallmind.nutsnbolts.util.DotNotation">
                      <property name="notation" value="*"/>
                    </bean>
                  </key>
                </entry>
              </map>
            </property>
          </bean>
        </property>
      </bean>
    </property>
    <property name="emitterMap">
      <map>
        <entry key="prometheus" value-ref="claxonEmitter"/>
      </map>
    </property>
  </bean>
</beans>
----

[[doppelganger, Doppelganger]]
= Doppelganger

[partintro]
Doppelganger is a set of annotations, and an APT (Annotation Processing Tool) conforming processor, that can generate multiple polymorphic-aware, fully-validated views of a class from a single description. These views are JAXB annotated and will translate themselves cleanly to and/or from JSON via any JAXB compliant implementation (including Jackson). Doppelganger generated views can construct themselves from the instances from which they were generated, or act as a factory for such instances. They understand references to other Doppelganger annotated classes, including arrays and collections of such classes, and will automatically encode/decode such references into/from their appropriate views (or collections of those views). The multiple views inherent in Doppelganger annotations can be used to both limit and validate the generated classes for CRUD (create, read, update and delete) use cases, from a single annotated base entity. Doppelganger includes annotations that extend the generated views with fields which do not exist in the original class, allowing the construction of data from more client-friendly proxy attributes, made easier with the fluent API generated for every view.

== Install

[[scribe, Scribe]]
= Scribe

[partintro]
Scribe is a logging framework with no specific dependency on a logger endpoint. It can be safely used in libraries without forcing any particular notion of the endpoint logging system on the library adopter. It is programmatically configurable and has no proprietary configuration format. Scribe can consume and integrate both Apache Commons Logging and SLF4J logging. Scribe's adapters for endpoint logging systems are written as services, so, when choosing a logging endpoint in top-level projects, it's enough to include the desired module as a project dependency. Scribe has a notion of thread local context which flows through to the context implementations of endpoint logger adapters. Scribe is fast, efficient, and easy to extend. The implementation requirements for adapters, appenders, filters and formatters are clear and minimal.

== Install

To use Scribe you'll need the `scribe-pen` dependency, and, if using an endpoint logger, you'll need to add the appropriate `scribe-ink-*` module (these modules describe services, so use only the single dependency that matches your endpoint logging framework). Integration with Apache Commons Logging is achieved through adding the `scribe-apache` module, and with SLF4J by adding the `scribe-slf4j` module.

.Scribe Pen
[source,xml]
----
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>scribe-pen</artifactId>
  <version>LATEST</version>
</dependency>
----

.Scribe Ink
[source,xml]
----
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>scribe-ink-indigenous</artifactId>
  <version>LATEST</version>
</dependency>
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>scribe-ink-jdk</artifactId>
  <version>LATEST</version>
</dependency>
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>scribe-ink-log4j</artifactId>
  <version>LATEST</version>
</dependency>
----

.Scribe Integrations
[source,xml]
----
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>scribe-apache</artifactId>
  <version>LATEST</version>
</dependency>
<dependency>
  <groupId>org.smallmind</groupId>
  <artifactId>scribe-slf4j</artifactId>
  <version>LATEST</version>
</dependency>
----

== Acknowledgments

Thanks to SLF4J.

== Design Choices

There are a few simple reasons for designing yet another logging framework almost no one will ever use...

* Programmatic configuration at its heart. Nothing but dependency injection.
* Simple implementation of extensions with no priveleged internals and minimal biases.
* No logging level checks necessary because expensive operations are delayed until the output stage.
* Where an expensive operation is necessary, it can be defined in a way which allows its execution to be delayed until the output stage.
* Native message formatting using the _printf_ style from `String.format()`.
* The last argument in *all* logging methods is the _var args_ for message formatting, and this includes those methods which take an Exception (so you can add an exception without losing formatted messages).

And that last reason is honestly the one which started this project. Hopefully it's not the only one for using it, but, for us, it's enough.

[[scribe-logger, Logger]]
== Logger

[small]#`org.smallmind.scribe.pen.Logger`#

The mechanism of logging in Scribe is a Logger. A logger has a <<scribe-logger-name>> and a <<scribe-level>> at which it will log, may have a <<scribe-logger-context>>, holds <<scribe-appenders>>, <<scribe-filters>> and <<scribe-enhancers>>, and can decorate logs with <<scribe-parameters>>. The basic function of a Logger is expressed through its `log()` methods....

* `void log (Level level, String message, Object... args)`
* `void log (Level level, Throwable throwable)`
* `void log (Level level, Throwable throwable, String message, Object... args)`
* `void log (Level level, Object object)`
* `void log (Level level, Throwable throwable, Object object)`
* `void log (Level level, Supplier<String> supplier)`
* `void log (Level level, Throwable throwable, Supplier<String> supplier)`

Each log statement has a _<<scribe-level>>_ at which it will be logged, can take a _Throwable_ to provide the stack trace output of an error, and takes one of three forms of message body...

* *Formatted* - Formatted messages take a base _String_ message and an optional set of arguments. If any arguments are passed, the message will be interpreted as a formatting template via the `String.format()` method, with the arguments passed as the formatting arguments.
* *Object* - If a single _Object_ is provided as the log message, the output will be the result of the object's `toString()` method. As message interpolation is delayed until after all filtering, this is one way of guaranteeing that complex or expensive operations to generate a log message will not be performed unless they are needed.
* *Supplier* - If a single _Supplier<String>_ is provided as the log message, the ouput will be the result of the supplier's `get()` method. As with using a simple _Object_ above, this can be used to delay complex or expensive operations until they are required.

For the sake of clarity and convenience, the above methods are replicated, once for each available log <<scribe-level>> (sans the _Level_ parameter, obviously), as in...

.An Info level log with a formatted messge
[source,java]
----
void info (String message, Object... args)
----

...or...

.A Warn level log with a _Throwable_ and _Supplier_
[source,java]
----
void warn (Throwable throwable, Supplier<String> supplier)
----

[[scribe-logger-name, Name]]
=== Name

Every logger instance has a name by which it's retrieved (see <<scribe-logger-manager>> below), by which its configuration may be fine-tuned (see <<scribe-templates>> below), and by which it may be known in log output. Although the choice of name is yours, it's suggested that you stick with the name of the class doing the logging.

[[scribe-level, Level]]
=== Level

[small]#`org.smallmind.scribe.pen.Level`#

The available log levels, which provide for basic categorization and filtering of log entries, are represented by the *Level* enum, which contains the following ordinal values...

* *TRACE* - Intended for very fine gained more-than-debug logging.
* *DEBUG* - For traditional debug logs.
* *INFO* - Informational messages, for example service startups and shutdowns, initial conditions, etc.
* *WARN* - Intended for possible problems or misconfigurations which do not rise to the level of overt errors.
* *ERROR* - A notice that something has gone wrong, often including an exception.
* *FATAL* - Intended for world-stopping events which cause shutdown or other unrecoverable states.
* *OFF* - Do not log. For use on <<scribe-logger>> instances or <<scribe-appenders>>, in order to shut them off. This should *never* be used as the level of a `log()` event.

[[scribe-logger-context, LoggerContext]]
=== LoggerContext

[small]#`LoggerContext`#

Some loggers are capable of adding information about the point in the code at which logging was initiated. This 'logger context' may include...

* `String getClassName()` - The class which in which the logger was called.
* `String getMethodName()` - The method from which the logger was called.
* `String getFileName()` - The name of the file containing the code which initiated the logging call.
* `int getLineNumber()` - The line number of the initiating call in the file containing the calling code.
* `boolean isNativeMethod()` - Whether the valling code represents a native method (via C interface).

There is some overhead to gathering this information, so the capability to automatically include it can but turned on/off via the `setAutoFillLoggerContext()` method on the logger.

[[scribe-appenders, Appenders]]
=== Appenders

[small]#`org.smallmind.scribe.pen.Appender`#

Appenders are the vehicle for publishing log records. What 'publishing' means is up to the appender implementation. Appenders can take <<scribe-filters>>, and implementations should honor them. An appender can be set inactive, via the `setActive()` method, and inactive appenders should not output log records. An appender can also have an instance of <<scribe-error-handler>> set on it, which will be called upon to handle uncaught errors in the appender's `publish()` method.

[[scribe-formatted-appender, FormattedAppender]]
==== Formatted Appender

[small]#`org.smallmind.scribe.pen.FormattedAppender`#

A FormattedAppender takes an implementation of <<scribe-formatter>> which will determine the structure of its output (as defined by the appender).

[[scribe-formatter, Formatter]]
===== Formatter

[small]#`org.smallmind.scribe.pen.Formatter`#

A formatter takes a log <<scribe-record>> and returns a string to be output by an appender by fulfilling...

[source,java]
----
String format (Record record)
  throws Exception;
----

There are a couple of useful formatters included with this project.

[[scribe-xml-formatter, XMLFormatter]]
====== XMLFormatter

[small]#`org.smallmind.scribe.pen.XMLFormatter`#

The XMLFormatter provides, unsurprisingly, an xml formatted output. There are a few attributes you can set on the formatter to configure its behavior...

* *timestamp* (_org.smallmind.scribe.pen.Timestamp_) - Controls how dates are formatted. Defaults to "yyyy-MM-dd'T'HH:mm:ss.SSSZ".
* *newLine* (_String_) - The line separator used when pretty printing the output. Defaults to `System.getProperty("line.separator")`.
* *cdata* (_boolean_) - If true then the output of any stack trace will be wrapped in `<![CDATA[ ... ]]>` markers. Defaults to false.
* *indent* (_int_) - The number of spaces used when pretty printing the output. Defaults to a 3 space indent.
* *recordElements* (_org.smallmind.scribe.pen.RecordElement[]_) - An array of enum values representing the elements which will be included in the output. Defaults to all of the below...
** *DATE* - The date this log record was emitted.
** *LEVEL* - The <<scribe-level>> at which this log record was emitted.
** *LOGGER_NAME* - The name of the logger emitting this record.
** *LOGGER_CONTEXT* - The <<scribe-logger-context>> of this log record (if available).
** *MESSAGE* - The log message attached to this record.
** *MILLISECONDS* - The epoch milliseconds at which this record was emitted.
** *PARAMETERS* - The <<scribe-parameters>> available to this record.
** *STACK_TRACE* - The stack trace of any _Throwable_ set on this record.
** *THREAD* - Information about the thread which carried this logging call.

====== PatternFormatter

[small]#`org.smallmind.scribe.pen.PatternFormatter`#

The pattern formatter is a flexible log record formatter with a traditional output style. This formatter takes only two configuration parameters...

* *timestamp* (_org.smallmind.scribe.pen.Timestamp_) - Controls how dates are formatted. Defaults to "yyyy-MM-dd'T'HH:mm:ss.SSSZ".
* *format* (_String_) - The operation of the format string is similar to that of _String_ formatting flags...
+
====
Portrayed as a regular expression, each flag has the general form of...

[source,regexp]
----
({[^%]+)?%((+|-)?(\d+))?(.\d*)?(!(+|-)[^!]*!)?([dtnlmTCMNLFsp])([^}]+})?
----

Let's take this apart piece by piece...

. *{_header_* - An optional header starts with `{` followed by any text which does not contain a `%`.
. *%* - The `%` declares a formatting field which will be substituted according to the possible conversions (see below).
. *``+|-``_width_* - Sets the maximum field length, where the optional ``+`` or ``-`` is used to denote a right or left padded field, if the field length is less than the width specifier. If this segment is absent, then no padding will be used.
. *._precision_* - An optional precision starts with a `.` and is used in the dot notated fields (logger name `n` and context class `C`) to specify a maximum number of segments to display, starting from the right. The precision specifier is also used in the multi-line conversion fields (currently just parameters `p`), to specify the maximum number of lines displayed (as a multi-line list). The precision specifier will be ignored on all other field types.
+
[NOTE]
For example, given a logger name of `com.mydomain.myproject.MyClass` and a format flag of `%.2n`, the conversion would print `myproject.MyClass`.
. *!``+|-``_prefix_!* - The `!...!` markers specify a line separator for, and optional prefix text to insert before, each line of a multi-line field (parameters `p`). The `+` or `-` is required, and sets whether the *first* line should also be prefixed with the text (`+` for true and `-` for false).
+
[NOTE]
For example, the marker `!-,\n!` would tell the formatter to insert a comma followed by a line-break before each line of a multi-line field, _excluding_ the first, which would present a comma separated list. The default used is equivalent to `!+\n\t!`, or a new-line followed by a tab starting each output line, _including_ the first.
. *conversion* - The available conversion flags are...
* *d* - The date stamp of the log entry (defaults to yyyy-MM-dd'T'HH:mm:ss.SSSZ).
* *t* - The time stamp of the entry in milliseconds.
* *n* - The logger name.
* *l* - The logger <<scribe-level>>.
* *m* - The log message.
* *T* - The name of the thread in which the logging occurred (if available).
* *C* - The class from which the log event was issued (if available).
* *M* - The method in which the log event was issued (if available).
* *N* - Whether the method which issued the log event was native code or not [true or false] (if available).
* *L* - The line number in the class file from which the log event was issued (if available).
* *F* - The file name of the class file from which the log event was issued (if available).
* *s* - The stack trace associated with the log event (if present). Although this is a multi-line field, it's formatting is the same as that used by the `printStackTrace()` method.
* *p* - The parameters associated with the log event (if present). This is a multi-line field.
. *_footer_}* - Optional footer text which is any string which does not contain, but does end with a `}`.

[TIP]
_The sequence `%%` outputs a single `%`, the sequence `\n` will be replaced by the platform specific line separator, and the sequence `\t` will be replaced by a tab._
====

[NOTE]
====
For example, the following format string...

`%d %n %+5l (%.1C.%M:%L) [%T] - %m%!+\n\t!p%!+\n\t!s`

...will produce the date, a space, the logger name, a space, the logging level (if the level is less than 5 characters it will br right padded to that length), a space, a left parenthesis, the right-most segment of the name of the calling class, a period, the method name from which the log statement was issued, a colon, the line number at which the log was issued, a right parenthesis, a space, a left bracket, the name of the context thread, a right bracket, a space, a dash, a space, the log message, any parameters available (each one preceded by a new line followed by a tab), and, finally, any stack trace preceded by a new line and tab (if there is a stack trace).
====

==== Out Of The Box

This project includes a few appenders you may find useful.

[[scribe-abstract-appender, AbstractAppender]]
===== AbstractAppender

[small]#`org.smallmind.scribe.pen.AbstractAppender`#

Not an appender in its own right, but a useful base class for complete implementations. This abstract class insures a minimum of correct fields and takes proper care of a few housekeeping chores, like calling an <<scribe-error-handler>> when the `publish()` method fails. In order stsndardize this behavior, _AbstractAppender_ fulfills the `publish()` method, while sub-classes should should implement...

[source,java]
----
public abstract void handleOutput (Record record)
  throws Exception;
----

[[scribe-error-handler, ErrorHandler]]
====== ErrorHandler

[small]#`org.smallmind.scribe.pen.ErrorHandler`#

An error handler provides an opportunity for sub-classes of AbstractAppender to find a way to notify client code when the normal log publishing operation fails unexpectedly. When designing an error handler, it's important to keep in mind that notification options may be limited, as the usual venue for logging has just failed. One way to make use of this capability would be to use `org.smallmind.scribe.pen.DefaultErrorHandler`, which takes another appender upon construction and attempts to log the resulting error using this alternate route. Using a <<scribe-console-appender>> as the alternate logger can be a safe bet, although the efficacy of this solution will depend upon how the client code is handling standard out. Creating an error handler is just a matter of implementing...

====
[source,java]
----
void process (Record record, Exception exception, String errorMessage, Object... args);
----

...where _record_ is the original log record, _exception_ is the exception thrown from the failed `publish()` method, and the _errorMessage_ and _args_ represent a suggestion for an additional message about the error.
====

===== AbstractFormattedAppender

[small]#`org.smallmind.scribe.pen.AbstractFormattedAppender`#

Simply the formatted version of an <<scribe-abstract-appender>>, for completeness and convenience.

===== AsynchronousAppender

[small]#`org.smallmind.scribe.pen.AsynchronousAppender`#

The AsynchronousAppender is not a complete appender, but rather an appender wrapper which takes `publish()` requests, puts them on a queue, and returns immediately. It holds a background thread which completes the publishing operation asynchronously. To use the AsynchronousAppender you pass its constructor another appender implementation and a buffer size for the queue. If the queue is full at the time the asynchronous appender's `publish()` method is called, an exception will be thrown to that effect.

[[scribe-console-appender, ConsoleAppender]]
===== ConsoleAppender

[small]#`org.smallmind.scribe.pen.ConsoleAppender`#

The ConsoleAppender is a <<scribe-formatted-appender>> that outputs log records to standard out, i.e. _System.out_.

===== EmailAppender

[small]#`org.smallmind.scribe.pen.EmailAppender`#

A <<scribe-formatted-appender>> appender which sends each log record as the body of an email. You should use this judiciously, unless you like a *lot* of email. This appender requires...

* *smtpServer* (_String_) - The smtp server host.
* *smtpPort* (_int_) - The smtp server port.
* *authentication* (_org.smallmind.nutsnbolts.email.Authentication_) - An authentication structure if required by the server.
* *secure* (_boolean_) - An optional flag noting that the smtp server is using a secure transport.
* *from* (_String_) - The email address of the sender.
* *to* (_String_) - The email address of the recipient.
* *subject* (_String_) - The subject of the emails.

===== FileAppender

[small]#`org.smallmind.scribe.pen.FileAppender`#

A <<scribe-formatted-appender>> appender which publishes its log records to a file. There are multiple constructors for this class, but in the end the important parameters are...

* *logPath* (_java.nio.file.Path_) - The path of the file to which log records are appended, which will be created as necessary.
* *rollover* (_<<scribe-rollover>>_) - An object describing the rules for archiving log files whenever they get too large, or too old.
* *cleanup* (_<<scribe-cleanup>>_) - An object describing the rules for cleaning up archived log files when they have gotten too old, or too numerous.

[[scribe-rollover, Rollover]]
====== Rollover

A rollover describes the rules for archiving log files which meet the requirements of its rule set. The files will be archived by copying them into the parent of the log path (as siblings of the current log file), with a file name which templates the original file name by adding a timestamp and an ordinal integer, separated by a singe character (which defaults to `-`).

[NOTE]
For example, if the original log name is `project.log`, then the archived file might be `project-1996-07-04-0.log`.

The rollover is configured by the following parameters...

* *separator* (_char_) - The separator used between the file name, the date and the ordinal index. Defauts to the `-` character.
* *timestamp* (_org.smallmind.scribe.pen.Timestamp_) - Controls how dates are formatted. Defaults to "yyyy-MM-dd'T'HH:mm:ss.SSSZ".
* *rules* (_org.smallmind.scribe.pen.RolloverRule[]_) - An array of rollover rules. The file will be archived and rolled over if any of the rules is true. This project comes with the following implementations...
+
====
*FileSizeRolloverRule*

[small]#`org.smallmind.scribe.pen.FileSizeRolloverRule`#

Sets the maximum size log files are allowed to reach before being archived and rolled over.
====
+
====
*TimestampRolloverRule*

[small]#`org.smallmind.scribe.pen.TimestampRolloverRule`#

Sets the time at which the current log file will be archived and rolled over.
====

[[scribe-cleanup, Cleanup]]
====== Cleanup

A cleanup instance describes the rules by which archived logs are deleted. The cleanup is configured with the following parameters...

* *separator* (_char_) - The separator used in the rollover for this FileAppender (required so the cleanup can properly parse the file names).
* *rules* (_org.smallmind.scribe.pen.CleanupRule[]_) - An array of cleanup rules. Any archived log files that match any of the given rules will be deleted. This project comes with the following implementations...
+
====
*FileCountCleanupRule*

[small]#`org.smallmind.scribe.pen.FileCountCleanupRule`#

Sets the maximum number of archived log files that will kept around. If the number of archived files exceeds the maximum in the rule, then the oldest files will be deleted first, until the total count of files is within bounds.
====
+
====
*LastModifiedCleanupRule*

[small]#`org.smallmind.scribe.pen.LastModifiedCleanupRule`#

Provides the maximum age an archived file is allowed to reach before being deleted.
====

===== FluentAppender

[small]#`org.smallmind.scribe.pen.FluentAppender`#

Thi appender's output format is the *_forward_* protocol (see https://docs.fluentd.org/input/forward) from FluentD/FluentBit. You'll obviously need a FluentD or FluentBit daemon running somewhere to make this useful. The following parameters are used to configure this appender...

* *host* (_String_) - The host on which the FluentD or FluentBit process is running.
* *port* (_int_) - The port for the fluent process.
* *timestamp* (_org.smallmind.scribe.pen.Timestamp_) - Controls how dates are formatted. Defaults to "yyyy-MM-dd'T'HH:mm:ss.SSSZ".
* *newLine* (_String_) - The line separator used to format the multi-line portions of the output. Defaults to `System.getProperty("line.separator")`.
* *retryAttempts* (_int_) - The number of times the appender will attempt to send a batch of log records before giving up.
* *batch* (_int) - The number of log records the appender will wait for and batch up into a single send.
* *recordElements* (_org.smallmind.scribe.pen.RecordElement[]_) - An array of enum values representing the elements which will be included in the output (same as for the <<scribe-xml-formatter>> above).
* *additionalEventData* (_Map<String, String>_) - A map of additional event parameters that will be included in each log record.

[[scribe-filters, Filters]]
=== Filters

[small]#`org.smallmind.scribe.pen.Filter`#

Both <<scribe-logger>> implementations and <<scribe-appenders>> can take filters. To implement a filter you need to fulfill the `willLog()` method...

[source,java]
----
boolean willLog (Record record);
----

If any filter in a set returns false for the method above, then the record will not be logged. This project comes with the following filters...

==== DotNotatedLoggerNameFilter

[small]#`org.smallmind.scribe.pen.DotNotatedLoggerNameFilter`#

A filter which allows log records through based on either meeting a particular _<<scribe-level>>_ and/or matching the logger's name with one of the dot notation patterns provided (see `org.smallmind.nutsnbolts.util.DotNotation`). By adding the same instance of this filter to every logger, a client of this project could dynamically control whether log records are output based on the logger name and level associated with each record. This might allow, for example, turning on debug logging across the system, or turning *all* logging on for a particular set of classes or modules.

==== LevelFilter

[small]#`org.smallmind.scribe.pen.LevelFilter`#

A basic level fiter. Log records are passed through that meet or exceed the <<scribe-level>> set on this filter.

[[scribe-enhancers, Enhancers]]
=== Enhancers

[small]#`org.smallmind.scribe.pen.Enhancer`#

An enhancer is essentially a log record decorator. A kind of log record 'get of jail free card', an enhancer can do whatever it wants with a log record by implementing the `enhance()` method...

[source,java]
----
void enhance (Record record);
----

[[scribe-parameters, Parameters]]
=== Parameters

[small]#`org.smallmind.scribe.pen.adapter.Parameters`#

A parameter is a key/value pair, properly held in thread local context, so they are capable of carrying cross-cutting concerns (or at least bits of data about such concerns). Although <<scribe-logger>> implementations may provide alternate integrations to the capabilities of endpoint logging systems, all of those provided by this project use the Parameters class, which is both a factory, and an implementation, of `org.smallmind.scribe.pen.adapter.ParameterAdapter`. To accommodate this behavior, you get the current instance via `Parameters.getInstance()`, upon which you may now call...

* `void put (String key, Serializable value)` - Puts a value into the backing thread local map.
* `void remove (String key)` - Removes a value from the backing thread local map.
* `void clear ()` - Clears the backing thread local map.
* `Serializable get (String key)` - Gets a value from the baking thread local map.
* `Parameter[] getParameters ()` - Get all parameters currently in the backing thread local map.

See the various implementations of <<scribe-formatter>> for the output of parameters to a log record.

[[scribe-logger-manager, LoggerManager]]
== LoggerManager

[small]#`org.smallmind.scribe.pen.LoggerManager`#

The LoggerManager class is the factory for <<scribe-logger>> instances. It's the static `getLogger()` method which returns an instance of a logger for use, and which takes either a `_String_` or `_Class<?>_` as parameter. The preferred method is to pass it the `_Class_` from which the resulting logger will be called, which makes organizing both loggers and their output relatively natural and tidy. This does mean you end up with, generally, a lot of loggers, which you'll need to configure with the appropriate objects and fields (such as <<scribe-level>>, <<scribe-appenders>>, <<scribe-filters>> and such). Rather than a complex system of hierarchical configurations and inheritances, this project uses <<scribe-templates>>.

[[scribe-templates, Templates]]
=== Templates

[small]#`org.smallmind.scribe.pen.Template`#

Templates can either be statically added to the <<scribe-logger-manager>>, or they will add themselves when their `register()` method is called, usually from the configuring dependency injection framework. Every template vies for the right to configure each logger with the set of objects it contains, with the strongest template winning. A template has methods for conveniently setting, and is a subsequent container for, the following information...

* *Appenders* (_<<scribe-appenders>>_) - A list of appenders which will be set on any matching logger.
* *AutoFillLoggerContext* (_boolean_) - Whether the matching logger will auto-fill its <<scribe-logger-context>>. Defaults to false.
* *Enhancers* (_<<scribe-enhancers>>_) - A list of enhancers which will be set on any matching logger.
* *Filters* (_<<scribe-filters>>_) - A list of filters which will be set on any matching logger.
* *Level* (_<<scribe-level>>_) - The default level for any matching logger. Defaults to _Level.INFO_.

We recommend generating a default template, which acts as a fallback default configuration, and then a set of templates which will bind themselves to the appropriate hierarchically named loggers as they are requested. Such a setup is not hard given the available template implementations.

[[scribe-class-name-template, ClassNameTemplate]]
==== ClassNameTemplate

[small]#`org.smallmind.scribe.pen.ClassNameTemplate`#

This template takes a dot-notated pattern upon construction (see `org.smallmind.nutsnbolts.util.DotNotation`), and binds to loggers based on the strength of the match with their names (which should, obviously, be dot notated). The binding strength is proportional to the number of matching segments in the pattern, with wild card segments valued as slightly weaker.

==== DefaultTemplate

[small]#`org.smallmind.scribe.pen.DefaultTemplate`#

This template will match any logger at the weakest possible binding value.

==== PeronalizedTemplate

[small]#`org.smallmind.scribe.pen.PersonalizedTemplate`#

This template takes a name upon construction and is all or nothing, matching any logger with exactly the same name, at the strongest possible binding value.

==== RegExTemplate

[small]#`org.smallmind.scribe.pen.RegexTemplate`#

Although the <<scribe-class-name-template>> is more flexible, and in general a better choice, this template can be used when logger names do not follow dot-notated conventions. This template take a regular expression upon construction, and binds to loggers whose names match the regular expression. The binding value is all or nothing, and will bind at the maximum strength if there's a match.

== Configuration

The following is one possible configuration that's demonstrative of a simple but realistic scenario. It's in Spring XML format, but should be indicative of what's necessary in any injection framework...

.Spring XML
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  <!-- Templates -->
  <bean id="defaultTemplate" class="org.smallmind.scribe.pen.DefaultTemplate" init-method="register">
    <property name="autoFillLoggerContext" value="true"/>
    <property name="appenders">
      <list>
        <ref bean="logAppender"/>
      </list>
    </property>
    <property name="level" value="INFO"/>
  </bean>

  <bean id="classNameTemplate" class="org.smallmind.scribe.pen.ClassNameTemplate" init-method="register">
    <property name="autoFillLoggerContext" value="true"/>
    <property name="pattern" value="com.mycompany.*"/>
    <property name="appenders">
      <list>
        <ref bean="logAppender"/>
      </list>
    </property>
    <property name="level" value="DEBUG"/>
  </bean>

  <!-- Logger -->
  <bean id="shortTimestamp" class="org.smallmind.scribe.pen.DateFormatTimestamp">
    <property name="dateFormat">
      <bean class="java.text.SimpleDateFormat">
        <constructor-arg index="0" value="yyyy-MM-dd"/>
      </bean>
    </property>
  </bean>

  <bean id="fullTimestamp" class="org.smallmind.scribe.pen.DateFormatTimestamp">
    <property name="dateFormat">
      <bean class="java.text.SimpleDateFormat">
        <constructor-arg index="0" value="yyyy-MM-dd'T'HH:mm:ss.SSSZ"/>
      </bean>
    </property>
  </bean>

  <bean id="patternFormatter" class="org.smallmind.scribe.pen.PatternFormatter">
    <property name="timestamp" ref="fullTimestamp"/>
    <property name="format" value="%d %n %+5l (%.1C.%M:%L) [%T] - %m%!+\n\t!p%!+\n\t!s"/>
  </bean>

  <bean id="rollover" class="org.smallmind.scribe.pen.Rollover">
    <property name="timestamp" ref="shortTimestamp"/>
    <property name="separator" value="."/>
    <property name="rules">
      <list>
        <bean class="org.smallmind.scribe.pen.TimestampRolloverRule">
          <property name="timestampQuantifier" value="TOP_OF_DAY"/>
        </bean>
        <bean class="org.smallmind.scribe.pen.FileSizeRolloverRule">
          <property name="fileSizeQuantifier" value="MEGABYTES"/>
          <property name="maxSize" value="100"/>
        </bean>
      </list>
    </property>
  </bean>

  <bean id="cleanup" class="org.smallmind.scribe.pen.Cleanup">
    <property name="separator" value="."/>
    <property name="rules">
      <list>
        <bean class="org.smallmind.scribe.pen.LastModifiedCleanupRule">
          <property name="stint">
            <bean class="org.smallmind.nutsnbolts.time.Stint">
              <constructor-arg index="0" name="time" value="30"/>
              <constructor-arg index="1" name="timeUnit" value="DAYS"/>
            </bean>
          </property>
        </bean>
      </list>
    </property>
  </bean>

  <bean id="consoleAppender" class="org.smallmind.scribe.pen.ConsoleAppender">
    <property name="formatter" ref="patternFormatter"/>
  </bean>

  <bean id="consoleErrorHandler" class="org.smallmind.scribe.pen.DefaultErrorHandler">
    <property name="backupAppender" ref="consoleAppender"/>
  </bean>

  <bean id="logAppender" class="org.smallmind.scribe.pen.AsynchronousAppender">
    <constructor-arg index="0" name="internalAppender">
      <bean class="org.smallmind.scribe.pen.FileAppender">
        <property name="logPath" value="/var/log/mycompany/myproject.log"/>
        <property name="rollover" ref="rollover"/>
        <property name="cleanup" ref="cleanup"/>
        <property name="formatter" ref="patternFormatter"/>
        <property name="errorHandler" ref="consoleErrorHandler"/>
      </bean>
    </constructor-arg>
    <constructor-arg index="1" name="bufferSize" value="300"/>
  </bean>
</beans>
----

== Adaptation

In order to adapt an endpoint logging framework for use by Scribe, you'll need to fulfill a set of contracts defined by the following classes...

=== LoggingBlueprint

[small]#`org.smallmind.scribe.pen.adapter.LoggingBlueprint`#

A LoggngBlueprint implementation is required to define a Java Service Provider for the `org.smallmind.scribe.pen.adapter.LoggingBlueprint` service interface. The overhead for this is pretty minimal, as all you really need is a file at */META-INF/services* named, literally, 'org.smallmind.scribe.pen.adapter.LoggingBlueprint', which contains a single line of text, and that text is the name of your implementation class. Your implementation will also need to complete the methods...

* `public <<scribe-logger-adapter>> getLoggingAdapter (String name)` - Given the logger name, retuns an adapter to a logger in the underlying framework.
* `public <<scribe-record>> errorRecord (<<scribe-record>> record, Throwable throwable, String message, Object... args)` - Should an error occur within an appender, such that the publishing contract cannot be fulfilled, the `org.smallmind.scribe.pen.DefaultErrorHandler` (if it's in use) will use this method to request a <<scribe-record>> compatible with the underlying framework, in order to try and call an alternate appender. The implementation should get any information it needs to construct the new record from the given parameters.

Because implementations of LoggingBlueprint are service providers, a client need only include the dependency containing the implementation in their build, and it will be loaded by the Scribe framework. The one twist is that a client can have no more than a _single_ endpoint integration defined within their transitive dependencies. It's therefore *important*, that any code intended as a library for use by others make no attempt to include any endpoint integration within its own runtime dependency set.

[[scribe-logger-adapter, LoggerAdapter]]
=== LoggerAdapter

[small]#`org.smallmind.scribe.pen.adapter.LoggingAdapter`#

A LoggerAdapter is a shim into the underlying logging framework being integrated into Scribe. The methods are self-explanatory so we'll avoid a method by method breakdown here. If you have questions, the implementations provided by this project should provide for ample examples.

[[scribe-record, Record]]
=== Record

A Record is a Scribe container for all the elements which might be available for output in a single logged event. As an implementation detail, the integrations in this project tend to extend the underlying notion of a such an event with the Record interface, guaranteeing that both are available within a single representative object.

=== Parameter Adapter

A ParameterAdapter provides access to a map of key/value pairs which should ideally be held in a thread local state. This function can be conveniently fulfilled by simply wrapping the <<scribe-parameters>> helper class.

== Endpoint Loggers

This project provides adaptations for a few of the more popular endpoint logging systems, as well as a purely native alternative. Integration is achived simply by including *_one_* of the appropriate dependencies .

[[scribe-indigenous, Indigenous]]
=== Indigenous

A completely native implementation of an endpoint logger.

=== JDK Logging

Integration for JDK Logging. It's possible to completely configure the system via Scribe's programmatic configuration.

=== Log4J

Integration for the Log4J2 project. It's possible to completely configure the system via Scribe's programmatic configuration.

== Other Integrations

As Scribe is certainly not the only neutral logging framework available, nor the first, this project provides integration with some of these more popular alternatives as convenience to the adopter.

=== Apache Commons Logging Integration

Simply including the Apache Commons Logging integration module as a dependency will route the output from code using Apache Commons Logging through your configured Scribe loggers.

=== SLF4J Integration

Simply including the SLF4J integration module as a dependency will route the output from code using SLF4J through your configured Scribe loggers.

[[spark, Spark]]
= Spark

[partintro]
The Spark project consists of Maven packaging formats for the construction of self-contained executable build artifacts.

[[spark-singularity, Singularity]]
== Singularity

Singularity is a Maven packaging format for self-contained executable jars *with* all their dependencies. Notably, a Singularity package does *not* unpack and repack its dependencies. The original jar files are maintained, and their namespaces are preserved. The Singularity package will contain a boot class loader that understands the _jar within jar_ format. In order to speed class resolution and loading, offset indexes of entries within the jar library dependencies are built during package construction. There should be nothing special you need to do with your code to create a Singularity from it, other than defining the packaging and nominating a `public static void main (String... args)` entry point.
[TIP]
====
Code looking to obtain a class loader should use...
[source,java]
----
Thread.currentThread().getContextClassLoader();
----
...as the system class loader will not understand the _jar within jar_ packaging format.
====

=== Install

In order to have Maven create a self-contained jar you should declare the packaging as `singularity` and include the `spark-singularity-maven-plugin` as outlined below..

.Singularity Plugin
[source,xml]
----
<project>
  ...
  <packaging>singularity</packaging>
  ...
  <build>
    <plugins>
      <plugin>
        <groupId>org.smallmind</groupId>
        <artifactId>spark-singularity-maven-plugin</artifactId>
        <version>LATEST</version>
        <extensions>true</extensions>
        <configuration>
          <mainClass><!-- entry point class containing a main() method --></mainClass>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
----

=== Configuration

The following configuration attributes are supported by the plugin...

* *mainClass* (required) - An entry point class containing a standard `public static void main (String... args)` method.
+
.Example
[source,xml]
----
<mainClass>my.Main</mainClass>
----

* *skip* (optional, defaults to _false_) - If this attribute exists and is set `true`, then the plugin will skip its operations and no artifact will be produced.
+
.Example
[source,xml]
----
<skip>true</skip>
----