= Smallmind
:doctype: book
:toc: left
A journey through glue code

[preface]
A preface

== About

=== Installation
All Smallmind modules are pushed to Maven Central under the *org.smallmind* group id. All artifacts which are intended to work together have the same sem version. Explicit module listings can be found in the various sections of this document covering those modules. Wherever possible, dependencies of this project are marked as `<optional>true</optional>`. This does require projects using these libraries to include such dependencies along with the relevant Smallmind modules, but keeps this project from making unwanted decisions. If we've missed any such opportunities, please let us know.

=== Configuration
There is none. IOC projects provide both the base container and configuration. Smallmind provides some occasionally helpful Spring beans, but there's no magic in them. Whatever flavor of dependency injection you prefer should work just as well.

=== Modules
* <<claxon>> - A unified monitoring framework with extensible meters and pluggable metric warehousing integrations (comes with Datadog, JMX, Logging and Prometheus).

[[claxon,Claxon]]
= Claxon

[partintro]
Claxon is a unified code instrumentation and metric gathering framework that abstracts away the underlying metric warehousing systems, allowing new systems to be plugged in and replaced as needed. Libraries can safely provide instrumentation in a warehouse agnostic fashion. New meters can be created without reference to the eventual warehousing system, and new warehouses can be integrated and used with all Claxon meters.

.Claxon Core
[source, xml]
----
      <dependency>
        <groupId>org.smallmind</groupId>
        <artifactId>claxon-registry</artifactId>
        <version>LATEST</version>
      </dependency>
----
.Claxon Push-based Integrations
[source, xml]
----
      <dependency>
        <groupId>org.smallmind</groupId>
        <artifactId>claxon-emitter-datadog</artifactId>
        <version>LATEST</version>
      </dependency>
      <dependency>
        <groupId>org.smallmind</groupId>
        <artifactId>claxon-emitter-jmx</artifactId>
        <version>LATEST</version>
      </dependency>
      <dependency>
        <groupId>org.smallmind</groupId>
        <artifactId>claxon-emitter-logging</artifactId>
        <version>LATEST</version>
      </dependency>
----
.Claxon Pull-based Integrations
[source, xml]
----
      <dependency>
        <groupId>org.smallmind</groupId>
        <artifactId>claxon-emitter-prometheus</artifactId>
        <version>LATEST</version>
      </dependency>
      <dependency>
        <groupId>org.smallmind</groupId>
        <artifactId>claxon-http</artifactId>
        <version>LATEST</version>
      </dependency>
----

== Design Choices
Metric warehousing systems such as StatsD, InfluxDB or Prometheus all store and provide for the querying of time series data. Some systems allow for the calculation of aggregations (minimums, maximums, velocity, histograms, etc.) upon storing data points, or as part of the provided query capabilities, while others do not. Some systems we may want to integrate with, such as JMX, have no notion of a time series at all. A project such as this one might fulfill its goals by fixing its notion of the meters it allows, and then pushing the best implementation of those meter types into the warehouse integrations. This would allow integrations with systems with a built-in notion of aggregations to take advantage of those capabilities. We have instead chosen to ignore these differences between warehousing systems, and separate the implementation of meters from the underlying capabilities of the various warehousing systems. That doesn't mean that you can't choose to build your own meters and warehousing integrations that are more tightly coupled, it just means that the meters provided by this project all aggregate on the client, and are uniformly usable on both the provided warehouse integrations, or with new integrations you may choose to create. It means that this framework does not privilege its provided meters in any way, and all of its capabilities, including AOP instrumentation annotations, are extended to any meters you choose to create. This also means that you can create new warehouse integrations without having to provide implementations for any meters at all, and those integrations will be usable with all meters which fulfill the contracts for this project.

== Registry
The ClaxonRegistry holds both meters (`org.smallmind.claxon.registry.meter.Meter`) and warehouse integration bindings (`org.smallmind.claxon.registry.Emitter`). Meters should be obtained through the ClaxonRegistry, which accepts the MeterBuilder interface (org.smallmind.claxon.registry.meter.MeterBuilder) through its `register()` method, as opposed to meter implementations directly. MeterBuilder is intended to take only the necessary parameters for constructing instances of Meter, and to be itself lightweight, so that the cost of not building a meter (if already present in the registry) is negligible. If the construction of a meter can't be directly trivialized, this project provides a lazy indirection (`org.smallmind.claxon.registry.meter.LazyBuilder`) which can delay the use of a MeterBuilder until the point of necessity. On the back side, implementations of Emitter are bound by name through the registry's `bind()` method, and called with all aggregated metrics on the configured collection interval. Let's take a closer look at the useful bits...

=== Bind
[small]#`ClaxonRegistry bind(String name, Emitter emitter)`#

Installs and binds an emitter to the specified name, which will then start receiving updates. Reusing a name will rebind that name to the new emitter.

[[claxon-registry-register, Register]]
=== Register
[small]#`<M extends Meter> M register(Class<?> caller, MeterBuilder<M> builder, Tag... tags)`#

Creates and registers a meter if it's not already registered, otherwise returns the currently registered meter. A meter's uniqueness is a combination of the caller's class and the tags passed as parameters to this method. Although the calling class is intended to be the direct caller of this method, that's not a requirement. Think of it the same way many logging systems use a class as the log name, which is intended, but not required to be the class doing the logging. In a similar fashion, whether this meter actually outputs any metrics, and the namespace of those metrics (as passed to this registries bound emitters), will depend upon the class of the caller (see <<claxon-configuration>>). Every possible Meter should have a MeterBuilder available. We recommend that a meter of type Foo have a builder in the same package named FooBuilder, and this is the practice followed in this project. This MeterBuilder makes up the second parameter to this method, followed by any tags, where a Tag is a simple key/value pair of strings.

==== Example
registry.register(MyInstance.class, new GaugeBuilder(), new Tag("event", "update"), new Tag("source", "mysql"))

[TIP]
Many metric warehouses are capable of storing and querying multi-dimensional data, and it's the tags used in creating a metric which will become the dimensions of the time series formed by the metric's values. Where a warehouse system is not multi-dimensional, the tags will be used to determine the time series data's hierarchical namespace. In either case, it's best to use tags with consistent ordering and limited cardinality (see <<claxon-tags>> for further advice).

=== Unregister
[small]#`void unregister(Class<?> caller, Tag... tags)`#

You should probably avoid unregistering and re-registering a meter, but if you know that a meter will no longer be used, and should be available for garbage collection, you can call this method.

=== Track _Observable_
[small]#`<O extends Observable> O track(Class<?> caller, MeterBuilder<?> builder, O observable, Tag... tags)`#

Registers a meter that will track changes in an Observable. The Observable instance is only weakly referenced by the meter, so that if the meter is the only remaining reference to the Observable instance, the meter will be unregistered and both the Observable instance and the meter will be available for garbage collection.

=== Track _Lambda_
[small]#`<T> T track(Class<?> caller, MeterBuilder<?> builder, T measured, Function<T, Long> measurement, Tag... tags)`#

Registers a meter that will poll the state of a 'measured' instance on the registry's collection interval using the supplied measurement function. Much like the tracking of Observables above, the measured instance is weakly held, such that if the meter is the only remaining reference, the meter will be unregistered and both the measured instance and the meter will be available for garbage collection.

[[claxon-configuration, Configuration]]
=== Configuration
The configuration for Claxon is simple and, like all SmallMind modules, programmatic. A configuration instance is composed of the following types...

* *Clock* (_clock_) - A clock can provide both wall time (think milliseconds since the epoch) and monotonic time (think nanoseconds). The default clock should work perfectly well, so you should not normally need to set your own.
* *Stint* (_collectionStint_) - The collection interval. The default value represents a 2-second interval.
* *Tag[]* (_registryTags_) - A set of default tags which are to be added to every meter. The default value is empty.
* *Map<DotNotation, String>* (_prefixMap_) - A mapping from DotNotation instances (see <<claxon-dot-notation>> below) to meter names. When a meter is registered (see <<claxon-registry-register>> above) the name of the `Class<?> caller` parameter (literally the `getName()` method of the Class) is matched against all known DotNotation instances. If a DotNotation can't be found that matches the class name, no meter will be registered, and no metrics will be emitted. If one or more matches are found, the strongest match, which is the one matching the most dot notated segments in the name, will determine the root name for all metric quantities produced by that meter. The full name of each quantity is the concatenation of the mapped String value of the winning DotNotation key and the name of the quantity produced by the meter. Exactly how that name is formed is dependent upon the logic of each Emitter (for the specifics see the <<claxon-emitters>> section below).
[NOTE]
Given a caller of `com.my.metered.MyInstance`, and a winning DotNotation entry with a value of "my.metrics", registering a meter that produces a quantity with the name of "duration", the DataDogEmitter would produce a data point named "my.metrics.duration". Notice how the class name of the caller parameter matters only for determining the matching DotNotation key.
[TIP]
If you wanted to emit all metrics with a single root name you could add a single _prefixMap_ entry like `put(new DotNotation("*"), "my.metrics")`. This may seem like a crowded name, but the name of any quantity should serve only to broadly categorize its value. The real namespace comes from the set of registered tags.

[[claxon-dot-notation, DotNotation]]
==== DotNotation
[small]#`org.smallmind.nutsnbolts.util.DotNotation`#

=== Instrumentation

[NOTE]
In order to turn on instrumentation features, you need to call `initializeInstrumentation()` on the configured Registry instance (the provided `org.smallmind.claxon.registry.spring.ClaxonRegistryFactoryBean` does this for you if you're using Spring).

==== Observables

==== Lambdas

== Meters

[[claxon-tags, Tags]]
== Tags

== Aspects

[[claxon-emitters, Emitters]]
== Emitters

There are essentially 2 different ways that metric warehouses ingest data, via either push (such as over a socket, REST API, or by method call) or pull (such as an HTTP scrape endpoint).

[NOTE]
Claxon supports both of these systems and provides a generic Jersey REST API endpoint for pull systems such as Prometheus. If you desire, building your own should be simple enough considering the few lines of code it took to implement *org.smallmind.claxon.http.EmitterResource* available in the *claxon-http* artifact.

=== DataDog

=== JMX

=== Message

=== Prometheus
Beware when using Prometheus that its scrape protocol is limited. You might think it would be easy enough to allow multiple data points for any single time series, within the same scrape Http body, by referencing the timestamp value the protocol allows to be included with each data point, and, where that was either not present or not sufficient, relying on the simple ordering of the values themselves. However, that is not the case and multiple data points for the same series will be lost. Due to this limitation, Claxon's Prometheus integration will only report the last data point received for any series since the last scrape request. It's important, therefore, to have your Prometheus instance scrape the Claxon endpoint at least as often as Claxon is set to report its aggregated values. In practical terms...

[WARNING]
The Prometheus collection interval must be less than or equal to the Claxon collection interval as defined by `ClaxonConfiguration.getCollectionStint()`, _or you may lose data points_.

= Scribe

[partintro]
Here

== Section 1

=== Sub Section

== Section 2

